#!/usr/bin/env bash

set -eu -o pipefail

# ------------------------------------------------------------------------------
# Params
# ------------------------------------------------------------------------------
PROGRAM="${0##*/}"
STORE="$HOME/.bashgpt/chat"
CHAT_HISTORY_FILE="$STORE/chat-history"
LAST_ASSISTANT_FILE="$STORE/last_assistant.conf"

# ------------------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------------------
ASSISTANT_NAME=""
ASSISTANT_ID=""
THREAD_ID=""
THREAD_LABEL=""
MESSAGE_ID=""

# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------
validate-env() {
  local tools=("curl" "jq" "gum" "openai")
  local cmd

  for cmd in "${tools[@]}"; do
    if ! command -v "$cmd" &> /dev/null; then
      echo "$cmd is not installed" >&2

      if [ "$cmd" == "openai" ]; then
        echo " - $cmd is a beta tool provided by this project." >&2
        echo ' - You can make it available by putting it on your PATH' >&2
        # shellcheck disable=SC2016
        echo '      export PATH="$PATH:/path/to/bash-gpt"' >&2
      fi

      exit 1
    fi
  done

  if [ -z "${OPENAI_API_KEY:-}" ]; then
    die "OPENAI_API_KEY is not set in the environment"
  elif [[ ! "$OPENAI_API_KEY" =~ ^sk-[a-zA-Z0-9]{32,64}$ ]]; then
    die "OPENAI_API_KEY is not a valid key"
  fi

  mkdir -p "$STORE"

  touch "$CHAT_HISTORY_FILE"
  touch "$LAST_ASSISTANT_FILE"

  restore-selected-assistant

  return 0
}

warn() {
  local msg="${1:-something went wrong}"
  gum style --foreground="#FF0000" "$PROGRAM: $msg" >&2
}

die() {
  warn "$@"
  exit 1
}

# ------------------------------------------------------------------------------
# API calls
# ------------------------------------------------------------------------------
get-completion() {
  local model="$1"
  local system="$2"
  local prompt="$3"
  local result

  if ! result=$(openai get-completion --model "$model" --system "$system" --prompt "$prompt"); then
    warn "error getting completion"
    die "$result"
  fi

  jq -r '.choices[0].message.content' <<< "$result"
}

list-assistants() {
  local result

  if ! result=$(openai list-assistants); then
    warn "error listing assistants"
    die "$result"
  fi

  while IFS=$'\t' read -r id name; do
    echo "$id:$name"
  done < <(jq -r '.data[] | "\(.id)\t\(.name // "null")"' <<< "$result")
}

create-assistant() {
  local name="$1"
  local instructions="$2"
  local description="$3"
  local tools=()
  local tool_args=()

  # gum choose returns a space-separated list of selected tools, so we read it into an array
  IFS=' ' read -r -a tools <<< "$4"

  # Build the tool arguments
  for tool in "${tools[@]}"; do
    [[ -n "$tool" ]] && tool_args+=(--tool "$tool")
  done

  # Now include the tool arguments in the openai invocation
  if ! result=$(openai create-assistant --name "$name" --instructions "$instructions" --description "$description" "${tool_args[@]}" 2>&1); then
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

start-thread() {
  local result
  local id

  if ! result=$(openai start-thread); then
    warn "error creating a new thread"
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

send-msg() {
  local msg="$1"
  local result

  if ! result=$(openai add-message --thread "$THREAD_ID" --content "$msg"); then
    warn "error sending message"
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

run-thread() {
  local result

  if ! result=$(openai run-thread --assistant "$ASSISTANT_ID" --thread "$THREAD_ID"); then
    warn "error running thread"
    die "$result"
  else
    jq -r '.id' <<< "$result"
  fi
}

get-run-status() {
  local run_id="$1"
  local result

  if ! result=$(openai get-run --thread "$THREAD_ID" --run "$run_id"); then
    warn "error getting run"
    die "$result"
  fi

  jq -r '.status' <<< "$result"
}

print-user-msg() {
  local msg="$1"

  if [[ "$msg" =~ ^Attached\ file:\ (.*)$ ]]; then
    msg="Attached file: $(gum style --faint "${BASH_REMATCH[1]}")"
  fi

  gum style --foreground '#00FF00' --bold 'You:'
  gum format "$msg"
}

print-gpt-msg() {
  local msg="$1"
  gum style --foreground '#66CCFF' --bold "$ASSISTANT_NAME:"
  gum format "$msg"
}

list-messages() {
  local messages
  local role
  local text

  messages=$(openai list-messages --thread "$THREAD_ID" --order "asc" --after "$MESSAGE_ID")

  jq -c '.data[] | {role: .role, text: .content[0].text.value}' <<< "$messages" | while IFS= read -r line; do
    MESSAGE_ID=$(jq -r '.id' <<< "$line")

    role=$(jq -r '.role' <<< "$line")
    text=$(jq -r '.text' <<< "$line")

    if [[ "$role" == "user" ]]; then
      print-user-msg "$text"
    else
      print-gpt-msg "$text"
    fi
  done
}

# ------------------------------------------------------------------------------
# Features
# ------------------------------------------------------------------------------
add-assistant() {
  local name
  local instructions
  local description
  local tools

  name=$(gum input --prompt 'Enter a name for the assistant: ' --placeholder 'Gene Peetee') || return 0
  [[ -z "$name" ]] && {
    warn "name is required"
    return 1
  }

  instructions=$(gum input --prompt 'Give it some custom instructions: ' --placeholder 'You are a helpful chatbot.') || return 0
  [[ -z "$instructions" ]] && {
    warn "instructions are required"
    return 1
  }

  description=$(gum input --prompt 'Enter an optional description: ' --placeholder 'Gene Peetee, the helpful chatbot.')

  tools="$(gum choose --header 'Select any add-on tools you want available to the assistant' --no-limit {none,code_interpreter,retrieval,function})" || true
  tools=$(echo "$tools" | sed '/^none$/d;/^$/d')

  ASSISTANT_ID=$(create-assistant "$name" "$instructions" "$description" "$tools")
  ASSISTANT_NAME="$name"

  save-selected-assistant
}

save-selected-assistant() {
  echo "$ASSISTANT_ID" > "$LAST_ASSISTANT_FILE"
  echo "$ASSISTANT_NAME" >> "$LAST_ASSISTANT_FILE"
}

restore-selected-assistant() {
  local last_assistant

  if [ -f "$LAST_ASSISTANT_FILE" ]; then
    readarray -t last_assistant < "$LAST_ASSISTANT_FILE"

    if [ "${#last_assistant[@]}" -ne 2 ]; then
      rm "$LAST_ASSISTANT_FILE"
      touch "$LAST_ASSISTANT_FILE"
      return 0
    fi

    ASSISTANT_ID="${last_assistant[0]}"
    ASSISTANT_NAME="${last_assistant[1]}"
  fi
}

# ------------------------------------------------------------------------------
# The fun bit here is that I had GPT generate these messages. Meta AF, me.
# ------------------------------------------------------------------------------
get-random-polling-message() {
  local messages=(
    "Analyzing tensor matrices..."
    "Consulting with virtual neurons..."
    "Assembling insights from data streams..."
    "Generating response with algorithmic magic..."
    "Beaming queries into the neural network..."
    "Harnessing the power of machine learning..."
    "Crunching numbers and patterns..."
    "Channeling the computational oracles..."
    "Navigating layers of deep learning..."
    "Synthesizing knowledge from the digital aether..."
    "Calibrating language models for wisdom..."
    "Propagating activations through the network..."
    "Eliciting secrets from the realm of data..."
    "Optimizing synaptic connections virtually..."
    "Invoking the syntactic synthesis ritual..."
    "Pondering the query in the silicon mind..."
    "Querying the knowledge graph..."
    "Counting electric sheep..."
  )

  local idx=$((RANDOM % ${#messages[@]}))
  echo "${messages[$idx]}"
}

send-msg-and-wait() {
  local msg="$1"
  local result
  local run_id

  MESSAGE_ID=$(send-msg "$msg")
  print-user-msg "$msg"
  run_id=$(run-thread)

  while true; do
    case $(get-run-status "$run_id") in
      queued | in_progress)
        gum spin -s dot --title.foreground="#00FF00" --title "$(get-random-polling-message)" -- sleep 3
        ;;

      completed)
        return 0
        ;;

      *)
        warn "got unexpected status: not sure what to do"
        die "$result"
        ;;
    esac
  done
}

attach-file() {
  local filepath="${1:-}"
  local filename
  local message

  # If no argument provided, use file picker
  if [[ -z $filepath ]]; then
    filepath=$(gum file .) || return 0
  fi

  # Ensure the file exists before proceeding
  if [[ ! -f $filepath ]]; then
    echo "File does not exist: $filepath" >&2
    return 0
  fi

  filename=$(basename "$filepath")
  message="Attached file: $filename\n\n\`\`\`$(cat "$filepath")\`\`\`"

  MESSAGE_ID=$(send-msg "$message")
  print-user-msg "$message"
}

chat() {
  local placeholder="ctrl-d submits | esc cancels | send \\f to attach a file"
  local needs_summary=false
  local messages
  local msg

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  if [ -z "$THREAD_ID" ]; then
    die "No chat is selected"
  fi

  if [ "$THREAD_LABEL" == "New chat with $ASSISTANT_NAME" ]; then
    needs_summary=true
  fi

  while true; do
    messages=$(list-messages)

    while IFS= read -r line; do
      printf "%s\n" "$line"
    done <<< "$messages"

    while true; do
      echo
      msg=$(
        gum write \
          --width 100 \
          --height 10 \
          --char-limit 0 \
          --placeholder "$placeholder" \
          --header ">>> $THREAD_LABEL <<<" \
          --header.foreground="#00FF00" \
          --cursor.mode=static \
          || true
      )

      case "$msg" in
        '')
          break 2
          ;;

        '\f')
          attach-file
          continue
          ;;

        '\f '*)
          local file_path="${msg#\\f }"
          attach-file "$file_path"
          continue
          ;;

        '\resummarize')
          save-to-chat-history
          continue
          ;;

        *)
          send-msg-and-wait "$msg"

          if [ "$needs_summary" = true ]; then
            save-to-chat-history
            needs_summary=false
          fi

          break
          ;;
      esac
    done
  done
}

save-to-chat-history() {
  if grep "$ASSISTANT_ID:$THREAD_ID:" "$CHAT_HISTORY_FILE" > /dev/null; then
    sed -i "/$ASSISTANT_ID:$THREAD_ID:/d" "$CHAT_HISTORY_FILE"
  fi

  THREAD_LABEL=$(summarize-chat)
  printf '%s\n' "$ASSISTANT_ID:$THREAD_ID:$THREAD_LABEL" >> "$CHAT_HISTORY_FILE"
}

summarize-chat() {
  get-completion \
    'gpt-3.5-turbo-16k' \
    'You are a bot that summarizes conversations tersely' \
    "$(list-messages)\n\nSummarize the above conversation in 10 words or less"
}

new-chat() {
  THREAD_ID=$(start-thread)
  THREAD_LABEL="New chat with $ASSISTANT_NAME"
  MESSAGE_ID=""
  chat
}

list-chats() {
  local assistant_id
  local thread_id
  local label

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  tac "$CHAT_HISTORY_FILE" | while IFS=':' read -r assistant_id thread_id label; do
    if [ "$assistant_id" == "$ASSISTANT_ID" ]; then
      echo -e "$label ($(gum style --faint "id: $thread_id"))"
    fi
  done
}

# ------------------------------------------------------------------------------
# Menus
# ------------------------------------------------------------------------------
assistant-menu() {
  local choices=()
  local selected

  while IFS=':' read -r id name; do
    choices+=("$name ($(gum style --faint "id: $id"))")
  done < <(list-assistants)

  choices+=("Create a new assistant")

  selected=$(gum choose --header "Select an assistant" "${choices[@]}") || return 0

  case "$selected" in
    "")
      return 0
      ;;

    "Create a new assistant")
      add-assistant
      ;;

    *)
      ASSISTANT_ID="$(echo "$selected" | sed -E 's/.*id: ([^)]+).*/\1/')"
      ASSISTANT_NAME="$(echo "$selected" | sed -E 's/^(.*) \(id: [^)]+\)$/\1/')"
      save-selected-assistant
      ;;
  esac
}

chat-menu() {
  local choices
  local selected

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  choices=(
    "Start a new chat"
    "Continue a previous chat with $ASSISTANT_NAME"
  )

  selected=$(gum choose --header "Chats" "${choices[@]}") \
    || return 0

  case "$selected" in
    "")
      return 0
      ;;

    "Start a new chat")
      new-chat
      ;;

    "Continue a previous chat with $ASSISTANT_NAME")
      chat-history-menu
      ;;
  esac
}

chat-history-menu() {
  local choice
  local height

  height=$(($(tput lines) - 2)) # -2 lines for gum filter's header and input

  choice=$(
    list-chats \
      | gum filter \
        --header "Conversation history" \
        --placeholder "Search" \
        --no-fuzzy \
        --height "$height" \
      || true
  )

  if [ -n "$choice" ]; then
    THREAD_ID="$(echo "$choice" | sed -E 's/.*id: ([^)]+).*/\1/')"
    THREAD_LABEL="$(echo "$choice" | sed -E 's/^(.*) \(id: [^)]+\)$/\1/')"
    MESSAGE_ID=""
    chat
  else
    return 0
  fi
}

main-menu() {
  local choices
  local selected

  while true; do
    clear

    choices=()

    if [ -n "$ASSISTANT_NAME" ]; then
      choices+=("Chat with $ASSISTANT_NAME")
    fi

    choices+=(
      "Select an assistant"
      "Quit"
    )

    selected=$(gum choose --header "What would you like to do?" "${choices[@]}") \
      || return 0

    case "$selected" in
      "")
        continue
        ;;

      "Select an assistant")
        assistant-menu
        ;;

      "Chat with $ASSISTANT_NAME")
        chat-menu
        ;;

      "Quit")
        return 0
        ;;
    esac
  done
}

validate-env
main-menu
exit 0
