#!/usr/bin/env bash

set -eu -o pipefail

# ------------------------------------------------------------------------------
# Params
# ------------------------------------------------------------------------------
PROGRAM="${0##*/}"
STORE="$HOME/.bashgpt/chat"
CHAT_HISTORY_FILE="$STORE/chat-history"
LAST_ASSISTANT_FILE="$STORE/last_assistant.conf"
MAX_FILE_SIZE=30000
MAX_MSG_SIZE=15000

# ------------------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------------------
ASSISTANT_NAME=""
ASSISTANT_ID=""
THREAD_ID=""
THREAD_LABEL=""
MESSAGE_ID=""

# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------
validate-env() {
  local tools=("curl" "jq" "gum" "openai")
  local cmd

  for cmd in "${tools[@]}"; do
    if ! command -v "$cmd" &> /dev/null; then
      echo "$cmd is not installed" >&2

      if [ "$cmd" == "openai" ]; then
        echo " - $cmd is a beta tool provided by this project." >&2
        echo ' - You can make it available by putting it on your PATH' >&2
        # shellcheck disable=SC2016
        echo '      export PATH="$PATH:/path/to/bash-gpt"' >&2
      fi

      exit 1
    fi
  done

  if [ -z "${OPENAI_API_KEY:-}" ]; then
    die "OPENAI_API_KEY is not set in the environment"
  elif [[ ! "$OPENAI_API_KEY" =~ ^sk-[a-zA-Z0-9]{32,64}$ ]]; then
    die "OPENAI_API_KEY is not a valid key"
  fi

  mkdir -p "$STORE"

  touch "$CHAT_HISTORY_FILE"
  touch "$LAST_ASSISTANT_FILE"

  restore-selected-assistant

  return 0
}

info() {
  local msg="$1"
  gum style --foreground="#66FF66" "$PROGRAM: $msg" >&2
}

warn() {
  local msg="${1:-something went wrong}"
  gum style --foreground="#FFFF00" "$PROGRAM: $msg" >&2
}

die() {
  local msg="${1:-something went wrong}"
  gum style --foreground="#FF0000" "$PROGRAM: $msg" >&2
  exit 1
}

prompt() {
  gum confirm "$1"
}

# ------------------------------------------------------------------------------
# API calls
# ------------------------------------------------------------------------------
get-completion() {
  local model="$1"
  local system="$2"
  local prompt="$3"
  local result

  if ! result=$(openai get-completion --model "$model" --system "$system" --prompt "$prompt"); then
    warn "error getting completion"
    die "$result"
  fi

  jq -r '.choices[0].message.content' <<< "$result"
}

list-assistants() {
  local result

  if ! result=$(openai list-assistants); then
    warn "error listing assistants"
    die "$result"
  fi

  while IFS=$'\t' read -r id name; do
    echo "$id:$name"
  done < <(jq -r '.data[] | "\(.id)\t\(.name // "null")"' <<< "$result")
}

create-assistant() {
  local name="$1"
  local instructions="$2"
  local description="$3"
  local tools=()
  local tool_args=()

  # gum choose returns a space-separated list of selected tools, so we read it into an array
  IFS=' ' read -r -a tools <<< "$4"

  # Build the tool arguments
  for tool in "${tools[@]}"; do
    [[ -n "$tool" ]] && tool_args+=(--tool "$tool")
  done

  # Now include the tool arguments in the openai invocation
  if ! result=$(openai create-assistant --name "$name" --instructions "$instructions" --description "$description" "${tool_args[@]}" 2>&1); then
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

modify-assistant() {
  local name="$1"
  local instructions="$2"
  local description="$3"
  local tools=()
  local tool_args=()

  # gum choose returns a space-separated list of selected tools, so we read it into an array
  IFS=' ' read -r -a tools <<< "$4"

  # Build the tool arguments
  for tool in "${tools[@]}"; do
    [[ -n "$tool" ]] && tool_args+=(--tool "$tool")
  done

  # Now include the tool arguments in the openai invocation
  if ! result=$(openai modify-assistant --assistant "$ASSISTANT_ID" --name "$name" --instructions "$instructions" --description "$description" "${tool_args[@]}" 2>&1); then
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

delete-assistant() {
  local result

  if ! result=$(openai delete-assistant --assistant "$ASSISTANT_ID"); then
    warn "error deleting assistant"
    die "$result"
  fi

  ASSISTANT_ID=""
  ASSISTANT_NAME=""

  return 0
}

start-thread() {
  local result
  local id

  if ! result=$(openai start-thread); then
    warn "error creating a new thread"
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

send-msg() {
  local msg="$1"
  local result

  if ! result=$(openai add-message --thread "$THREAD_ID" --content "$msg"); then
    warn "error sending message"
    die "$result"
  fi

  print-user-msg "$msg"
}

# Called in bg proc
# shellcheck disable=2317
run-thread() {
  local result

  if ! result=$(openai run-thread --assistant "$ASSISTANT_ID" --thread "$THREAD_ID"); then
    warn "error running thread"
    die "$result"
  else
    jq -r '.id' <<< "$result"
  fi
}

# Called in bg proc
# shellcheck disable=2317
get-run-status() {
  local run_id="$1"
  local result

  if ! result=$(openai get-run --thread "$THREAD_ID" --run "$run_id"); then
    warn "error getting run"
    die "$result"
  fi

  jq -r '.status' <<< "$result"
}

print-user-msg() {
  local msg="$1"

  if [[ "$msg" =~ ^Attached\ file\ content: ]]; then
    msg=$(echo "$msg" | sed -n '1p')
  fi

  gum style --foreground '#66FF66' --bold 'You:'
  gum format "$msg"
}

print-gpt-msg() {
  local msg="$1"
  gum style --foreground '#66CCFF' --bold "$ASSISTANT_NAME:"
  gum format "$msg"
}

list-messages() {
  local limit=${1:-100}
  local get_all=${2:-true}
  local messages
  local role
  local text
  local has_more=true
  local lines

  while [ "$has_more" == true ]; do
    messages=$(openai list-messages --thread "$THREAD_ID" --order "asc" --after "$MESSAGE_ID" --limit "$limit")
    has_more=$(jq -r '.has_more' <<< "$messages")

    IFS=$'\n' read -r -d '' -a lines < <(jq -c '.data[] | {id: .id, role: .role, text: .content[0].text.value}' <<< "$messages" && printf '\0')

    for line in "${lines[@]}"; do
      MESSAGE_ID=$(jq -r '.id' <<< "$line")
      role=$(jq -r '.role' <<< "$line")
      text=$(jq -r '.text' <<< "$line")

      if [[ "$role" == "user" ]]; then
        print-user-msg "$text"
      else
        print-gpt-msg "$text"
      fi
    done

    if [ "$get_all" == false ]; then
      break
    fi
  done
}

# ------------------------------------------------------------------------------
# Features
# ------------------------------------------------------------------------------
add-assistant() {
  local name
  local instructions
  local description
  local tools

  name=$(gum input --prompt 'Enter a name for the assistant: ' --placeholder 'G. Peetee') || return 0

  [[ -z "$name" ]] && {
    name="G. Peetee"
  }

  instructions=$(
    gum write \
      --width 100 \
      --height 30 \
      --char-limit 0 \
      --placeholder "You are a helpful assistant" \
      --header "GPT instructions" \
      --header.foreground="#66FF66" \
      --cursor.mode=static \
      || true

  )

  [[ -z "$instructions" ]] && {
    instructions="You are a helpful chatbot."
  }

  description=$(gum input --prompt 'Enter an optional description: ' --placeholder 'Gene Peetee, the helpful chatbot.')

  tools="$(gum choose --header 'Select any add-on tools you want available to the assistant' --no-limit {none,code_interpreter,retrieval,function})" || true
  tools=$(echo "$tools" | sed '/^none$/d;/^$/d')

  ASSISTANT_ID=$(create-assistant "$name" "$instructions" "$description" "$tools")
  ASSISTANT_NAME="$name"

  save-selected-assistant
}

edit-assistant() {
  local result

  local name
  local instructions
  local description
  local tools

  local new_name
  local new_instructions
  local new_description
  local new_tools

  if ! result=$(openai get-assistant --assistant "$ASSISTANT_ID"); then
    warn "error getting assistant"
    die "$result"
  fi

  name=$(jq -r '.name' <<< "$result")
  instructions=$(jq -r '.instructions' <<< "$result")
  description=$(jq -r '.description' <<< "$result")
  tools=$(jq -r '.tools | map(.type) | join(" ")' <<< "$result")

  if ! new_name=$(gum input --prompt 'Enter a new name: ' --value "$name"); then
    return
  fi

  if ! new_instructions=$(gum write --width 100 --height 30 --char-limit 0 --value "$instructions" --header "Modify GPT instructions" --header.foreground="#66FF66" --cursor.mode=static); then
    return
  fi

  if ! new_description=$(gum input --prompt 'Modify description: ' --value "$description"); then
    return
  fi

  if ! new_tools=$(gum choose --header 'Update selected tools' --no-limit --selected "$tools" {none,code_interpreter,retrieval,function}); then
    return
  fi

  new_tools=$(echo "$new_tools" | sed '/^none$/d;/^$/d')

  if [ -z "$new_name" ] || [ -z "$new_instructions" ]; then
    # The user pressed escape on name or instructions, so we skip updating the
    # description and tools.
    new_name=$name
    new_instructions=$instructions
  fi

  ASSISTANT_ID=$(modify-assistant "$new_name" "$new_instructions" "$new_description" "$new_tools")
  ASSISTANT_NAME="$new_name"

  save-selected-assistant
}

del-assistant() {
  local old_id="$ASSISTANT_ID"
  local tmp

  gum confirm "Delete assistant $ASSISTANT_NAME (id: $ASSISTANT_ID)?" || return 0
  delete-assistant || return 0

  tmp=$(mktemp)
  if grep -v "^$old_id:" "$CHAT_HISTORY_FILE" > "$tmp"; then
    mv "$CHAT_HISTORY_FILE" "$CHAT_HISTORY_FILE.bak"
    mv "$tmp" "$CHAT_HISTORY_FILE"
    rm "$CHAT_HISTORY_FILE.bak"
  fi
}

save-selected-assistant() {
  echo "$ASSISTANT_ID" > "$LAST_ASSISTANT_FILE"
  echo "$ASSISTANT_NAME" >> "$LAST_ASSISTANT_FILE"
}

restore-selected-assistant() {
  local last_assistant

  if [ -f "$LAST_ASSISTANT_FILE" ]; then
    readarray -t last_assistant < "$LAST_ASSISTANT_FILE"

    if [ "${#last_assistant[@]}" -ne 2 ]; then
      rm "$LAST_ASSISTANT_FILE"
      touch "$LAST_ASSISTANT_FILE"
      return 0
    fi

    ASSISTANT_ID="${last_assistant[0]}"
    ASSISTANT_NAME="${last_assistant[1]}"
  fi
}

# ------------------------------------------------------------------------------
# The fun bit here is that I had GPT generate these messages. Meta AF, me.
# ------------------------------------------------------------------------------
# Initialize a global variable to store the last message index. Set to an invalid value initially.
LAST_MESSAGE_IDX=-1

get-random-polling-message() {
  local messages=(
    "Analyzing tensor matrices..."
    "Consulting with virtual neurons..."
    "Channeling the computational oracles..."
    "Calibrating language models..."
    "Propagating activations through the network..."
    "Optimizing synaptic connections virtually..."
    "Invoking the syntactic synthesis..."
    "Querying the knowledge graph..."
    "Counting electric sheep..."
    "Activating interlocks..."
    "Connecting dinotherms..."
    "Bringing up infracells..."
    "Megathrusters are go..."
    "Backfilling the quantum carburator..."
    "Bifurcating Schrödinger's catscan..."
    "Reversing the polarity of the flux quantum..."
    "Reconfiguring the quantum plumbus..."
    "Raising crimson shields..."
    "Replacing dilithium crystals with new Folder's Crystals, let's see if engineering notices..."
    "Taking a break to watch some interdimensional cable..."
  )

  local idx
  local message_count=${#messages[@]}

  # Generate a random index, but ensure it's not the same as the last one
  while :; do
    idx=$((RANDOM % message_count))
    if [[ $idx -ne $LAST_MESSAGE_IDX ]]; then
      LAST_MESSAGE_IDX=$idx
      break
    fi
  done

  echo "${messages[$idx]}"
}

SPINNER_TMP_FILES=()
cleanup-spinner() {
  for temp_file in "${SPINNER_TMP_FILES[@]}"; do
    rm -f "$temp_file"
  done

  SPINNER_TMP_FILES=()
}

spinner() {
  local stdout
  local stderr
  local cmd_pid
  local cmd_exit_status

  stdout=$(mktemp)
  stderr=$(mktemp)
  SPINNER_TMP_FILES+=("$stdout" "$stderr")

  # Set trap to ensure cleanup runs on exit and interrupt
  trap cleanup-spinner EXIT INT TERM

  # Run the command in the background, redirecting stdout and stderr
  ("$@" > "$stdout" 2> "$stderr") &
  cmd_pid=$!

  # Poll for subprocess status
  while kill -0 "$cmd_pid" 2> /dev/null; do
    gum spin -s dot --title.foreground="#66FF66" --title "$(get-random-polling-message)" -- sleep 3
  done

  # Wait for the command to finish and capture its exit status
  wait "$cmd_pid"
  cmd_exit_status=$?

  # Output the command's stdout and stderr
  cat "$stdout"
  cat "$stderr" >&2

  # Remove the temporary files
  cleanup-spinner

  # Return the exit status of the command
  return $cmd_exit_status
}

# shellcheck disable=SC2317
run-thread-and-wait() {
  local result
  local run_id
  local status

  run_id=$(run-thread)

  while true; do
    status=$(get-run-status "$run_id")

    case "$status" in
      queued | in_progress)
        sleep 1
        continue
        ;;

      completed)
        return 0
        ;;

      *)
        warn "got unexpected status: not sure what to do"
        die "$result"
        ;;
    esac
  done
}

# shellcheck disable=SC2317
split-into-chunks() {
  local chunk_size=$1
  local str=$2
  local chunk

  while [ -n "$str" ]; do
    chunk=${str:0:$chunk_size}
    echo -n "$chunk" # Print chunk without a trailing newline
    echo -ne "\0"    # Use null byte as delimiter
    str=${str:$chunk_size}
  done
}

# shellcheck disable=SC2317
attach-file() {
  local filepath
  local content
  local action
  local msg

  if [ -z "$*" ]; then
    filepath=$(find . -type f | grep -v '.git' | gum filter --header 'Select a file to attach' --fuzzy) || return 0
  else
    filepath="$1"
  fi

  # Remove leading whitespace, if any
  filepath="${filepath#"${filepath%%[![:space:]]*}"}"

  # Remove trailing whitespace, if any
  filepath="${filepath%"${filepath##*[![:space:]]}"}"

  if [[ ! -f "$filepath" ]]; then
    warn "File does not exist: '$filepath'"
    return 0
  fi

  content=$(< "$filepath")

  if ((${#content} > MAX_FILE_SIZE)); then
    warn "The file content exceeds the maximum allowed size."

    action_truncate="Truncate file to fit the limit"
    action_split="Split the content into multiple messages"
    action_cancel="Cancel the operation"

    action=$(gum choose --header "How would you like to proceed?" "$action_truncate" "$action_split" "$action_cancel")

    case "$action" in
      "$action_truncate")
        content="${content:0:MAX_FILE_SIZE}"
        ;;

      "$action_split")
        # Calculate maximum size for a chunk of content, considering markdown and headers
        local total_characters=${#content}
        local part_no=0
        local chunk
        local pct

        while IFS= read -r -d '' chunk; do # Read until null byte
          part_no=$((part_no + 1))

          pct=$((part_no * MAX_FILE_SIZE * 100 / total_characters))
          if ((pct > 100)); then
            pct=100
          fi

          info "Sending chunk ${part_no} (${#chunk} characters) - ${pct}% complete"

          # shellcheck disable=SC2016
          msg=$(printf 'Attached file content: `%s` (part %s)\n```\n%s\n```\n' "$filepath" "$part_no" "$chunk")
          echo -e "$msg" | base64

          sleep 1 # Adding a short delay to avoid rapid message sending
        done < <(split-into-chunks "$MAX_FILE_SIZE" "$content")

        return 0
        ;;

      "$action_cancel")
        return 0
        ;;

      *)
        return 0
        ;;
    esac
  fi

  # shellcheck disable=SC2016
  msg=$(printf 'Attached file content: `%s`\n```\n%s\n```\n' "$filepath" "$content")
  echo -e "$msg" | base64
}

# shellcheck disable=SC2317
attach-command-output() {
  local command="$1"
  local command_output
  local command_status
  local msg

  # Execute the command and capture its output
  command_output=$(eval "$command" 2>&1)
  command_status=$?
  command_output=$(printf "\`\`\`sh\n\$ %s\n%s\n# exit status: %s\n\`\`\`" "$command" "$command_output" "$command_status")

  if ((${#command_output} > MAX_MSG_SIZE)); then
    local total_characters=${#command_output}
    local part_no=0
    local chunk
    local pct

    echo -e "Output of \`$command\` is too large to send in a single message. Sending in multiple messages instead." | base64

    while IFS= read -r -d '' chunk; do # Read until null byte
      part_no=$((part_no + 1))

      pct=$((part_no * MAX_FILE_SIZE * 100 / total_characters))
      if ((pct > 100)); then
        pct=100
      fi

      # shellcheck disable=SC2016
      msg=$(printf 'Command `%s` output continued (part %s):\n```\n%s\n```' "$command" "$part_no" "$chunk")
      echo -e "$msg" | base64

      sleep 1 # Adding a short delay to avoid rapid message sending
    done < <(split-into-chunks "$MAX_MSG_SIZE" "$command_output")
  else
    # shellcheck disable=SC2016
    msg=$(printf 'Command `%s` output:\n```\n%s\n```' "$command" "$command_output")
    echo -e "$msg" | base64
  fi
}

parse-message() {
  local message="$1"
  local is_in_code_fence=false
  local command_block=""
  local inside_command_block=false
  local parsed_lines=()

  while IFS= read -r line; do
    # Do not process any directives within a markdown code fence
    if [[ "$line" =~ ^\`\`\` ]]; then
      # Toggle the is_in_code_fence flag
      if [ "$is_in_code_fence" = true ]; then
        is_in_code_fence=false
      else
        is_in_code_fence=true
      fi
      parsed_lines+=("TEXT $line")
    # We're not in a code fence - GAME ON
    elif [ "$is_in_code_fence" != true ]; then
      # Beginning of command block
      if [[ "$line" == \\begin ]]; then
        inside_command_block=true
        command_block=""
      # End of command block
      elif [[ "$line" == \\end ]] && $inside_command_block; then
        inside_command_block=false

        if [[ $command_block =~ [^[:space:]] ]]; then
          parsed_lines+=("EXEC $command_block")
        fi

        command_block=""
      # Inside of command block - collect commands
      elif $inside_command_block; then
        if [[ "$line" =~ \\$ ]]; then
          # Append part of command, trimming the trailing backslash
          command_block+="${line%\\} "
        else
          command_block+="$line"

          if [[ $command_block =~ [^[:space:]] ]]; then
            parsed_lines+=("EXEC $command_block")
          fi

          command_block=""
        fi
      # Single line command
      elif [[ "$line" =~ ^\\exec\ (.*) ]]; then
        parsed_lines+=("EXEC ${BASH_REMATCH[1]}")
      # File block
      elif [[ "$line" =~ ^\\f(.*) ]]; then
        parsed_lines+=("FILE ${BASH_REMATCH[1]}")
      # Normal message
      else
        parsed_lines+=("TEXT $line")
      fi
    else
      parsed_lines+=("TEXT $line")
    fi
  done <<< "$message"

  # Add any remaining non-empty commands to parsed_lines
  if [[ -n $command_block && $command_block =~ [^[:space:]] ]]; then
    parsed_lines+=("EXEC $command_block")
  fi

  printf "%s\n" "${parsed_lines[@]}"
}

join-by-newline() {
  local IFS=$'\n'
  echo "$*"
}

# shellcheck disable=SC2317
handle-parsed-message() {
  local parsed_lines=("$@")
  local messages=()
  local text_content=()

  for line in "${parsed_lines[@]}"; do
    case "$line" in
      TEXT*)
        text_content+=("${line#TEXT }")
        ;;

      EXEC*)
        if [ "${#text_content[@]}" -gt 0 ]; then
          messages+=("$(join-by-newline "${text_content[@]}")")
          text_content=()
        fi

        local exec_line="${line#EXEC }"
        local msgs=()
        local msg
        readarray -t msgs < <(attach-command-output "$exec_line")

        for msg in "${msgs[@]}"; do
          msg=$(base64 --decode <<< "$msg")
          if [ -n "$msg" ]; then
            messages+=("$msg")
          fi
        done
        ;;

      FILE*)
        if [ "${#text_content[@]}" -gt 0 ]; then
          messages+=("$(join-by-newline "${text_content[@]}")")
          text_content=()
        fi

        local file_path="${line#FILE }"
        local msgs=()
        local msg
        readarray -t msgs < <(attach-file "${file_path}")

        for msg in "${msgs[@]}"; do
          msg=$(base64 --decode <<< "$msg")
          if [ -n "$msg" ]; then
            messages+=("$msg")
          fi
        done
        ;;

      *)
        warn "Unhandled message type: $line"
        ;;
    esac
  done

  if [ "${#text_content[@]}" -gt 0 ]; then
    messages+=("$(join-by-newline "${text_content[@]}")")
    text_content=()
  fi

  for msg in "${messages[@]}"; do
    send-msg "$msg"
    sleep 0.5
  done

  echo "${#messages[@]}"
}

chat() {
  local placeholder="ctrl-d submits | esc cancels | send \\f to attach a file | \\exec to embed 1-liner | \\begin..\\end to embed multi-line command"
  local needs_summary=false
  local initialized=false
  local msgs_sent
  local msg

  # Come on, shellcheck, this is clearly a string, not an array. Seriously,
  # `read` operates just fine on here-strings.
  # shellcheck disable=SC2178
  local messages=""

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  if [ -z "$THREAD_ID" ]; then
    die "No chat is selected"
  fi

  if [ "$THREAD_LABEL" == "New chat with $ASSISTANT_NAME" ]; then
    needs_summary=true
  fi

  while true; do
    if [ "$initialized" == false ]; then
      if [ "$THREAD_LABEL" != "New chat with $ASSISTANT_NAME" ]; then
        info "Retrieving conversation..."
        move-chat-to-beginning-of-history
        clear
      fi

      initialized=true
    fi

    list-messages

    while true; do
      msg=$(
        gum write \
          --width 140 \
          --height 15 \
          --char-limit 0 \
          --placeholder "$placeholder" \
          --header ">>> $THREAD_LABEL (id: $THREAD_ID) <<<" \
          --header.foreground="#66FF66" \
          --cursor.mode=static \
          || true
      )

      case "$msg" in
        '')
          break 2
          ;;

        '\rename')
          save-to-chat-history
          break
          ;;

        '\run')
          spinner run-thread-and-wait
          break
          ;;

        *)
          IFS=$'\n' read -r -d '' -a parsed_lines < <(parse-message "$msg" && printf '\0')
          msgs_sent=$(handle-parsed-message "${parsed_lines[@]}")

          if [ "$msgs_sent" == 0 ]; then
            break
          fi

          # If any messages were sent, update the display to show them while we
          # wait for the thread to run.
          list-messages

          spinner run-thread-and-wait

          if [ "$needs_summary" = true ]; then
            save-to-chat-history
            needs_summary=false
          fi

          break
          ;;

      esac
    done
  done
}

move-chat-to-beginning-of-history() {
  local temp_file
  local chat_entry

  temp_file=$(mktemp)
  chat_entry=$(grep "^$ASSISTANT_ID:$THREAD_ID:" "$CHAT_HISTORY_FILE")

  # Remove the existing chat entry, if any, from the chat history
  grep -v "^$ASSISTANT_ID:$THREAD_ID:" "$CHAT_HISTORY_FILE" > "$temp_file"

  # Add the chat entry to the "beginning" of the history file
  {
    cat "$temp_file"
    echo "$chat_entry"
  } > "$CHAT_HISTORY_FILE"

  # Clean up
  rm -f "$temp_file"
}

save-to-chat-history() {
  # goddamnit apple
  if [[ "$(uname)" == "Darwin" ]]; then
    SED_INPLACE_FLAG='-i ""'
  else
    SED_INPLACE_FLAG='-i'
  fi

  if grep "$ASSISTANT_ID:$THREAD_ID:" "$CHAT_HISTORY_FILE" > /dev/null; then
    eval "sed $SED_INPLACE_FLAG '/$ASSISTANT_ID:$THREAD_ID:/d' '$CHAT_HISTORY_FILE'"
  fi

  THREAD_LABEL=$(summarize-chat)
  printf '%s\n' "$ASSISTANT_ID:$THREAD_ID:$THREAD_LABEL" >> "$CHAT_HISTORY_FILE"
}

summarize-chat() {
  get-completion \
    'gpt-3.5-turbo-16k' \
    'You are a bot that summarizes conversations tersely' \
    "$(list-messages 6 false)\n\nSummarize the above conversation in 10 words or less"
}

new-chat() {
  THREAD_ID=$(start-thread)
  THREAD_LABEL="New chat with $ASSISTANT_NAME"
  MESSAGE_ID=""
  chat
}

list-chats() {
  local assistant_id
  local thread_id
  local label

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  tac "$CHAT_HISTORY_FILE" | while IFS=':' read -r assistant_id thread_id label; do
    if [ "$assistant_id" == "$ASSISTANT_ID" ]; then
      echo -e "$label ($(gum style --faint "id: $thread_id"))"
    fi
  done
}

# ------------------------------------------------------------------------------
# Menus
# ------------------------------------------------------------------------------
assistant-menu() {
  local choices=()
  local header
  local selected

  while true; do
    clear
    choices=()

    while IFS=':' read -r id name; do
      choices+=("$name ($(gum style --faint "id: $id"))")
    done < <(list-assistants)

    choices+=("Create a new assistant")

    if [ -n "$ASSISTANT_ID" ]; then
      choices+=('Edit' 'Delete')
    fi

    choices+=("Back")

    header="Assistants"
    if [ -n "$ASSISTANT_ID" ]; then
      header="$header (selected: $ASSISTANT_NAME)"
    fi

    selected=$(gum choose --header "$header" "${choices[@]}") || return 0

    case "$selected" in
      "" | "Back")
        break
        ;;

      "Create a new assistant")
        add-assistant
        ;;

      "Edit")
        edit-assistant
        ;;

      "Delete")
        del-assistant
        ;;

      *)
        ASSISTANT_ID="$(echo "$selected" | sed -E 's/.*id: ([^)]+).*/\1/')"
        ASSISTANT_NAME="$(echo "$selected" | sed -E 's/^(.*) \(id: [^)]+\)$/\1/')"
        save-selected-assistant
        break
        ;;
    esac
  done
}

chat-menu() {
  local choices=()
  local selected

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  while true; do
    clear

    choices=("Start a new chat")

    if grep "^$ASSISTANT_ID:" "$CHAT_HISTORY_FILE" > /dev/null; then
      choices+=("Continue a previous chat with $ASSISTANT_NAME")
    fi

    choices+=("Back")

    selected=$(gum choose --header "Chats" "${choices[@]}") || true

    case "$selected" in
      "" | "Back")
        break
        ;;

      "Start a new chat")
        new-chat
        ;;

      "Continue a previous chat with $ASSISTANT_NAME")
        chat-history-menu
        ;;
    esac
  done
}

chat-history-menu() {
  local choice
  local height
  local chats=()

  while true; do
    clear
    height=$(($(tput lines) - 2)) # -2 lines for gum filter's header and input

    chats=()
    while IFS= read -r line; do
      chats+=("$line")
    done < <(list-chats)

    if [ "${#chats[@]}" -eq 0 ]; then
      info 'No chat history found'
      read -r -p "Press enter to continue..." || true
      return 0
    fi

    choice=$(
      printf "%s\n" "${chats[@]}" \
        | gum filter \
          --header "Conversation history" \
          --placeholder "Search" \
          --no-fuzzy \
          --height "$height" \
        || true
    )

    if [ -n "$choice" ]; then
      THREAD_ID="$(echo "$choice" | sed -E 's/.*id: ([^)]+).*/\1/')"
      THREAD_LABEL="$(echo "$choice" | sed -E 's/^(.*) \(id: [^)]+\)$/\1/')"
      MESSAGE_ID=""
      chat
    else
      break
    fi
  done
}

main-menu() {
  local choices
  local selected

  while true; do
    clear

    choices=()
    if [ -n "$ASSISTANT_NAME" ]; then
      choices+=("Chat with $ASSISTANT_NAME")
    fi

    choices+=(
      "Assistants"
      "Quit"
    )

    selected=$(gum choose --header "What would you like to do?" "${choices[@]}") \
      || return 0

    case "$selected" in
      "")
        continue
        ;;

      "Assistants")
        assistant-menu
        ;;

      "Chat with $ASSISTANT_NAME")
        chat-menu
        ;;

      "Quit")
        return 0
        ;;
    esac
  done
}

validate-env

main-menu

exit 0
