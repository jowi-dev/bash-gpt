#!/usr/bin/env bash

set -eu -o pipefail

# ------------------------------------------------------------------------------
# Global variables
# ------------------------------------------------------------------------------

RED="\033[31m"
GREEN="\033[32m"
RESET="\033[0m"

CONVERSATIONS_DIR="${BASHGPT_CONVERSATION_HISTORY_DIR:-$HOME/.gpt/conversations}"
CONVERSATION_FILE="$CONVERSATIONS_DIR/$(date +%s).txt"

TITLE="New conversation"
CONVERSATION=()
CONVERSATION_TMP=$(mktemp)

# Ensure the conversations directory exists
mkdir -p "$CONVERSATIONS_DIR"

# ------------------------------------------------------------------------------
# Check for required tools and environment variables
# ------------------------------------------------------------------------------
if ! command gpt --help &> /dev/null; then
  echo >&2 "Error: gpt is not installed or is not on your PATH"
  echo >&2 "  - See https://github.com/sysread/bash-gpt for installation instructions"
  exit 1
fi

if ! command gum --help &> /dev/null; then
  echo >&2 "Error: gum is not installed or is not on your PATH"
  echo >&2 "  - See https://github.com/charmbracelet/gum for installation instructions"
  echo >&2 "  - Or just 'brew install gum' on macOS (with homebrew, obv)"
  exit 1
fi

gpt --check

# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------
usage() {
  local exit_code="${1:-0}"

  cat << EOL

usage: chat [OPTIONS]

Options:
  --help      | -h                 show help information

Environmental variables:

  OPENAI_API_KEY                   your OpenAI API key (required; create one at https://beta.openai.com/account/api-keys)
  OPENAI_MODEL                     the model to use; defaults to gpt-3.5-turbo-16k
  BASHGPT_CONVERSATION_HISTORY_DIR the directory to store conversation history; defaults to ~/.gpt/conversations
EOL

  exit "$exit_code"
}

serialize_conversation() {
  local output=""

  for ((i = 0; i < ${#CONVERSATION[@]}; i += 2)); do
    local prefix
    local msg="${CONVERSATION[i + 1]}"

    case "${CONVERSATION[i]}" in
      -u)
        prefix="User"
        ;;
      -s)
        prefix="System"
        ;;
      *)
        echo >&2 "Unknown type: ${CONVERSATION[i]}"
        exit 1
        ;;
    esac

    output+="${prefix}: ${msg}\n"
  done

  echo "$output"
}

update_title() {
  serialized_conversation="$1"
  TITLE=$(OPENAI_MODEL="gpt-3.5-turbo-16k" gpt -u "In 10 words or less summarize this text: $serialized_conversation")
}

save_conversation() {
  local convo

  convo=$(serialize_conversation)
  update_title "$convo"

  echo "Title: $TITLE" > "$CONVERSATION_FILE"
  echo -e "$convo" | sed 's/[[:space:]]*$//' >> "$CONVERSATION_FILE"
}

restore_conversation() {
  local current_prefix=""
  local current_message=""

  CONVERSATION_FILE="$1"
  CONVERSATION=()

  if [[ ! -e "$CONVERSATION_FILE" ]]; then
    echo >&2 "Conversation file does not exist: $CONVERSATION_FILE"
    exit 1
  fi

  while IFS= read -r line; do
    # Skip the title line
    if [[ "$line" == "Title:"* ]]; then
      TITLE="${line#*: }"

    # Detect prefix (either User: or System:) in the line
    elif [[ "$line" == "User:"* ]] || [[ "$line" == "System:"* ]]; then
      # Remove trailing whitespace from current_message
      current_message=$(echo -n "$current_message" | sed 's/[[:space:]]*$//')

      # If we were collecting a message, add it to the array
      if [ -n "$current_message" ]; then
        CONVERSATION+=("$current_prefix" "$current_message")
      fi

      # Set new prefix and clear the current message
      current_prefix=$([[ "$line" == "User:"* ]] && echo "-u" || echo "-s")
      current_message="${line#*: }"

    else
      # Append to the current message
      current_message+=$'\n'"$line"
    fi
  done < "$CONVERSATION_FILE"

  # Remove trailing whitespace from last message
  current_message=$(echo -n "$current_message" | sed 's/[[:space:]]*$//')

  # Add the last message to the array if it exists
  if [ -n "$current_message" ]; then
    CONVERSATION+=("$current_prefix" "$current_message")
  fi
}

repeat_conversation() {
  local prefix
  local msg

  for ((i = 0; i < ${#CONVERSATION[@]}; i += 2)); do
    msg="${CONVERSATION[i + 1]}"

    case "${CONVERSATION[i]}" in
      -u)
        prefix="${GREEN}You:${RESET}"
        ;;
      -s)
        prefix="${GREEN}GPT:${RESET}"
        ;;
    esac

    echo -e "$prefix"
    echo "$msg"
    echo
  done
}

list_conversations() {
  while IFS= read -r filename; do
    if [[ -f "$filename" ]]; then
      awk '/^Title: / { print substr($0, 8); exit }' "$filename"
    fi
  done < <(find "$CONVERSATIONS_DIR" -type f -name '*.txt' | xargs -I {} stat -f "%m %N" {} \
    | sort -rn | cut -d' ' -f2-)
}

select_conversation() {
  local choice
  local file
  local options

  options=$(list_conversations)

  if [[ -z "$options" ]]; then
    echo >&2 -e "${RED}No conversation history found${RESET}"
    echo >&2 "Press enter to continue"
    read -r

    return 1
  else
    choice=$(
      echo "$options" \
        | gum filter \
          --header "Conversation history" \
          --placeholder "Search" \
          --no-fuzzy \
        || true
    )

    if [ -n "$choice" ]; then
      file=$(find "$CONVERSATIONS_DIR" -name "*.txt" -exec grep -l "^Title: $choice" {} \;)
      restore_conversation "$file"
      return 0
    fi
  fi
}

attach_file() {
  local filepath
  local filename
  local instruction

  filepath=$(gum file .)
  filename=$(basename "$filepath")

  instruction=$(
    gum input \
      --char-limit 0 \
      --width 100 \
      --prompt "Prompt: " \
      --value "Attached is the content of $filename for your review"
  )

  CONVERSATION+=(-u "$instruction" -u "$(cat "$filepath")")
}

converse() {
  local placeholder="ctrl-d submits | esc cancels | send \\f to attach a file"

  while true; do
    msg=$(
      gum write \
        --width 100 \
        --height 20 \
        --char-limit 0 \
        --placeholder "$placeholder" \
        --header "$TITLE" \
        || true
    )

    case "$msg" in
      '')
        break
        ;;

      '\f')
        attach_file
        ;;

      *)
        CONVERSATION+=(-u "$msg")

        echo -e "${GREEN}You:${RESET}\n$msg\n"
        echo -e "${GREEN}GPT:${RESET}"

        # Initially display gpt's output as it arrives
        gpt --no-cache "${CONVERSATION[@]}" | tee "$CONVERSATION_TMP"

        CONVERSATION+=(-s "$(cat "$CONVERSATION_TMP")")
        save_conversation
        ;;
    esac
  done
}

# ------------------------------------------------------------------------------
# Argument parsing
# ------------------------------------------------------------------------------
while (("$#")); do
  case "$1" in
    --help | -h)
      usage 0
      ;;

    *)
      echo >&2 "Error: unknown argument '$1'"
      usage 1
      ;;
  esac
done

# ------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------
new_conversation="New conversation"
load_conversation="Load conversation"
quit="Quit (escape)"

choices=(
  "$new_conversation"
  "$load_conversation"
  "$quit"
)

while true; do
  clear

  case "$(gum choose --height 30 --header "BashGPT" --ordered "${choices[@]}")" in
    "$new_conversation")
      clear
      TITLE="New conversation"
      converse
      ;;

    "$load_conversation")
      if select_conversation; then
        clear
        repeat_conversation
        converse
      fi
      ;;

    "$quit" | "")
      exit 0

      ;;
  esac

done
