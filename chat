#!/usr/bin/env bash

set -eu -o pipefail

# ------------------------------------------------------------------------------
# Global variables
# ------------------------------------------------------------------------------
green="\033[32m"
reset="\033[0m"

conversations_dir="$HOME/.gpt/conversations"
conversation_file="$conversations_dir/$(date +%s).txt"

title="New conversation"
conversation=()
tmp=$(mktemp)

# Ensure the conversations directory exists
mkdir -p "$conversations_dir"

# ------------------------------------------------------------------------------
# Check for required tools and environment variables
# ------------------------------------------------------------------------------
if ! command gpt --help &> /dev/null; then
  echo >&2 "Error: gpt is not installed or is not on your PATH"
  echo >&2 "  - See https://github.com/sysread/bash-gpt for installation instructions"
  exit 1
fi

if ! command gum --help &> /dev/null; then
  echo >&2 "Error: gum is not installed or is not on your PATH"
  echo >&2 "  - See https://github.com/charmbracelet/gum for installation instructions"
  echo >&2 "  - Or just 'brew install gum' on macOS (with homebrew, obv)"
  exit 1
fi

gpt --check

# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------
serialize_conversation() {
  local output=""

  for ((i = 0; i < ${#conversation[@]}; i += 2)); do
    local prefix
    local msg="${conversation[i + 1]}"

    case "${conversation[i]}" in
      -u)
        prefix="User"
        ;;
      -s)
        prefix="System"
        ;;
      *)
        echo >&2 "Unknown type: ${conversation[i]}"
        exit 1
        ;;
    esac

    output+="${prefix}: ${msg}\n"
  done

  echo "$output"
}

update_title() {
  title=$(gpt -u "In 10 words or less summarize this text: $(serialize_conversation)")
}

save_conversation() {
  local convo

  convo=$(serialize_conversation)
  update_title

  echo "Title: $title" > "$conversation_file"
  echo -e "$convo" | sed 's/[[:space:]]*$//' >> "$conversation_file"
}

restore_conversation() {
  local current_prefix=""
  local current_message=""

  conversation_file="$1"
  conversation=()

  if [[ ! -e "$conversation_file" ]]; then
    echo >&2 "Conversation file does not exist: $conversation_file"
    exit 1
  fi

  while IFS= read -r line; do
    # Skip the title line
    if [[ "$line" == "Title:"* ]]; then
      title="${line#*: }"

    # Detect prefix (either User: or System:) in the line
    elif [[ "$line" == "User:"* ]] || [[ "$line" == "System:"* ]]; then
      # Remove trailing whitespace from current_message
      current_message=$(echo -n "$current_message" | sed 's/[[:space:]]*$//')

      # If we were collecting a message, add it to the array
      if [ -n "$current_message" ]; then
        conversation+=("$current_prefix" "$current_message")
      fi

      # Set new prefix and clear the current message
      current_prefix=$([[ "$line" == "User:"* ]] && echo "-u" || echo "-s")
      current_message="${line#*: }"

    else
      # Append to the current message
      current_message+=$'\n'"$line"
    fi
  done < "$conversation_file"

  # Remove trailing whitespace from last message
  current_message=$(echo -n "$current_message" | sed 's/[[:space:]]*$//')

  # Add the last message to the array if it exists
  if [ -n "$current_message" ]; then
    conversation+=("$current_prefix" "$current_message")
  fi
}

repeat_conversation() {
  local prefix
  local msg

  for ((i = 0; i < ${#conversation[@]}; i += 2)); do
    msg="${conversation[i + 1]}"

    case "${conversation[i]}" in
      -u)
        prefix="${green}You:${reset}"
        ;;
      -s)
        prefix="${green}GPT:${reset}"
        ;;
    esac

    echo -e "$prefix"
    echo "$msg"
    echo
  done
}

list_conversations() {
  local filename

  # shellcheck disable=SC2045
  for filename in $(ls -1t "$conversations_dir"/*.txt); do
    if [[ -f "$filename" ]]; then
      awk '/^Title: / { print substr($0, 8); exit }' "$filename"
    fi
  done
}

select_conversation() {
  local choice
  local file

  choice=$(
    list_conversations \
      | gum filter \
        --header "Conversation history" \
        --placeholder "Search" \
        --no-fuzzy \
      || true
  )

  if [ -n "$choice" ]; then
    file=$(find "$conversations_dir" -name "*.txt" -exec grep -l "^Title: $choice" {} \;)
    restore_conversation "$file"
    return 0
  fi

  return 1
}

attach_file() {
  local filepath
  local filename
  local instruction

  filepath=$(gum file .)
  filename=$(basename "$filepath")

  instruction=$(
    gum input \
      --char-limit 0 \
      --width 100 \
      --prompt "Prompt: " \
      --value "Attached is the content of $filename for your review"
  )

  conversation+=(-u "$instruction" -u "$(cat "$filepath")")
}

converse() {
  local placeholder="ctrl-d submits | esc cancels | send \\f to attach a file"

  while true; do
    msg=$(
      gum write \
        --width 100 \
        --height 20 \
        --char-limit 0 \
        --placeholder "$placeholder" \
        --header "$title" \
        || true
    )

    case "$msg" in
      '')
        break
        ;;

      '\f')
        attach_file
        ;;

      *)
        conversation+=(-u "$msg")

        echo -e "${green}You:${reset}\n$msg\n"
        echo -e "${green}GPT:${reset}"

        # Initially display gpt's output as it arrives
        gpt --no-cache "${conversation[@]}" | tee "$tmp"

        conversation+=(-s "$(cat "$tmp")")
        save_conversation
        ;;
    esac
  done
}

# ------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------
new_conversation="New conversation"
load_conversation="Load conversation"
quit="Quit (escape)"

choices=(
  "$new_conversation"
  "$load_conversation"
  "$quit"
)

while true; do
  clear

  case "$(gum choose --header "BashGPT" --ordered "${choices[@]}")" in
    "$new_conversation")
      clear
      title="New conversation"
      converse
      ;;

    "$load_conversation")
      if select_conversation; then
        clear
        repeat_conversation
        converse
      fi
      ;;

    "$quit" | "")
      exit 0

      ;;
  esac

done
